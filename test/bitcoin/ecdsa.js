//
// Tests for Bitcoin ECDSA
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//

var ec = require('../../src/bitcoin/jsbn/ec');
var Bitcoin = require('../../src/index');
var sec = require('../../src/bitcoin/jsbn/sec');
var Crypto = require('../../src/bitcoin/crypto-js/index');

var assert = require('assert');

var rng = new Bitcoin.SecureRandom();

describe('ECDSA', function() {
  var ecparams;
  before(function() {
    ecparams = sec.getSECCurveByName('secp256k1');
  });

  it('point multiplication', function() {
    var G = ecparams.getG();
    var n = ecparams.getN();

    assert.ok(G.multiply(n).isInfinity(), "Gn is infinite");

    var k = Bitcoin.ECDSA.getBigRandom(n);
    var P = G.multiply(k);
    assert.ok(!P.isInfinity(), "kG is not infinite");
    assert.ok(P.isOnCurve(), "kG on curve");
    assert.ok(P.multiply(n).isInfinity(), "kGn is infinite");

    assert.ok(P.validate(), "kG validates as a public key");
  });

  it('point equals', function() {
    var G = ecparams.getG();
    var n = ecparams.getN();
    var k1 = Bitcoin.ECDSA.getBigRandom(n);
    var k2 = Bitcoin.ECDSA.getBigRandom(n);

    var P1 = G.multiply(k1);
    var P2 = G.multiply(k2);
    var P3 = G.multiply(k1);

    assert.equal(P1.equals(P2), false);
    assert.equal(P1.equals(P3), true);
  });

  it('key management', function() {
    var s1 = new Bitcoin.ECKey();
    var p1 = s1.getPub();
    assert.equal(p1.length, 65, "Public key is correct length");

    var p1_q = ec.ECPointFp.decodeFrom(ecparams.getCurve(), p1);
    assert.ok(p1_q, "Decode point from generated bytestring");
    assert.ok(p1_q.validate(), "Is a valid public point");

    var p2 = Crypto.util.hexToBytes(
      "0486f356006a38b847bedec1bf47013776925d939d5a35a97a4d1263e550c7f1a" +
      "b5aba44ab74d22892097a0e851addf07ba97e33416df5affaceeb35d5607cd23c"
    );
    var p2_q = ec.ECPointFp.decodeFrom(ecparams.getCurve(), p2);
    assert.ok(p2_q, "Decode point from constant");
    assert.ok(p2_q.validate(), "Is a valid public point");
  });

  it('sign and verify', function() {
    var s1 = new Bitcoin.ECKey();
    var sig_a = s1.sign(Bitcoin.BigInteger.ZERO);
    assert.ok(sig_a, "Sign null");
    assert.ok(s1.verify(Bitcoin.BigInteger.ZERO, sig_a));

    var message = new Bitcoin.BigInteger(1024, rng).toByteArrayUnsigned();
    var hash = Crypto.SHA256(message, {asBytes: true});
    var sig_b = s1.sign(hash);
    assert.ok(sig_b, "Sign random string");
    assert.ok(s1.verify(hash, sig_b));

    var message2 = Crypto.util.hexToBytes(
      "12dce2c169986b3346827ffb2305cf393984627f5f9722a1b1368e933c8d" +
      "d296653fbe5d7ac031c4962ad0eb1c4298c3b91d244e1116b4a76a130c13" +
      "1e7aec7fa70184a71a2e66797052831511b93c6e8d72ae58a1980eaacb66" +
      "8a33f50d7cefb96a5dab897b5efcb99cbafb0d777cb83fc9b2115b69c0fa" +
      "3d82507b932b84e4"
    );
    var hash2 = Crypto.SHA256(message2, {asBytes: true});
    var sig_c = Crypto.util.hexToBytes(
      "3044022038d9b8dd5c9fbf330565c1f51d72a59ba869aeb2c2001be959d3" +
      "79e861ec71960220a73945f32cf90d03127d2c3410d16cee120fa1a4b4c3" +
      "f273ab082801a95506c4"
    );
    var s2 = Crypto.util.hexToBytes(
      "045a1594316e433fb91f35ef4874610d22177c3f1a1060f6c1e70a609d51" +
      "b20be5795cd2a5eae0d6b872ba42db95e9afaeea3fbb89e98099575b6828" +
      "609a978528"
    );
    assert.ok(Bitcoin.ECDSA.verify(hash2, sig_c, s2), "Verify constant signature");
  });
});


